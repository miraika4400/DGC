////////////////////////////////////////////////////
//
//    courseクラスの処理[course.cpp]
//    Author:増澤 未来
//
////////////////////////////////////////////////////

//******************************
// インクルード
//******************************
#include "course.h"
#include "manager.h"
#include "renderer.h"
#include "game.h"
#include "player.h"
#include "checkpoint.h"
#include "wall.h"
#include "start.h"

//*****************************
// マクロ定義
//*****************************
#define MODEL_PATH "./data/Models/Syokyuu_Course.x"    //モデルのパス
#define HOVER_HEIGHT 50
//*****************************
// 静的メンバ変数宣言
//*****************************
LPD3DXMESH   CCourse::m_pMeshModel[CCourse::COURSE_MAX] = {};   	//メッシュ情報へのポインタ
LPD3DXBUFFER CCourse::m_pBuffMatModel[CCourse::COURSE_MAX] = {};	//マテリアル情報へのポインタ
DWORD        CCourse::m_nNumMatModel[CCourse::COURSE_MAX] = {};	    //マテリアル情報の数
// テクスチャのパスの格納
char *CCourse::m_pTexPath[CCourse::COURSE_MAX] =
{
	MODEL_PATH,
	MODEL_PATH,
	MODEL_PATH
};
//******************************
// コンストラクタ
//******************************
CCourse::CCourse():CModel(OBJTYPE_MAP)
{
}

//******************************
// デストラクタ
//******************************
CCourse::~CCourse()
{
}

//******************************
// クリエイト
//******************************
CCourse * CCourse::Create(COURSETYPE type)
{
	// メモリの確保
	CCourse *pMap;
	pMap = new CCourse;
	// タイプの設定
	pMap->m_courseType = type;
	// 初期化
	pMap->Init();

	// 各値の代入・セット
	pMap->SetObjType(OBJTYPE_MAP); // オブジェクトタイプ
	
	return pMap;
}

//******************************
// テクスチャのロード
//******************************
HRESULT CCourse::Load(void)
{
	// デバイスの取得
	LPDIRECT3DDEVICE9 pDevice = CManager::GetRenderer()->GetDevice();
	
	// コース数分ループ
	for (int nCntCourse = 0; nCntCourse < COURSE_MAX; nCntCourse++)
	{
		//Xファイルの読み込み
		D3DXLoadMeshFromX(m_pTexPath[nCntCourse],
			D3DXMESH_SYSTEMMEM,
			pDevice,
			NULL,
			&m_pBuffMatModel[nCntCourse],
			NULL,
			&m_nNumMatModel[nCntCourse],
			&m_pMeshModel[nCntCourse]);

	}

	return S_OK;
}

//******************************
// テクスチャのアンロード
//******************************
void CCourse::Unload(void)
{
	for (int nCnt = 0; nCnt < COURSE_MAX; nCnt++)
	{
		//メッシュの破棄
		if (m_pMeshModel[nCnt] != NULL)
		{
			m_pMeshModel[nCnt]->Release();
			m_pMeshModel[nCnt] = NULL;
		}

		//マテリアルの破棄
		if (m_pBuffMatModel[nCnt] != NULL)
		{
			m_pBuffMatModel[nCnt]->Release();
			m_pBuffMatModel[nCnt] = NULL;
		}
	}
}


//******************************
// 初期化処理
//******************************
HRESULT CCourse::Init(void)
{
	if (FAILED(CModel::Init()))
	{
		return E_FAIL;
	}

	// テクスチャ割り当て
	BindModel(m_pMeshModel[m_courseType],m_pBuffMatModel[m_courseType],m_nNumMatModel[m_courseType]);
	// チェックポイントの生成
	CCheckPoint::Create(m_courseType);
	// 壁の生成
	CWall::Create(m_courseType);
	// スタートの生成
	CStart::Create(m_courseType);
	return S_OK;
}

//******************************
// 終了処理
//******************************
void CCourse::Uninit(void)
{
	CModel::Uninit();
}

//******************************
// 更新処理
//******************************
void CCourse::Update(void)
{
	// 当たり判定
	CollisionPlayer();
}

//******************************
// 描画処理
//******************************
void CCourse::Draw(void)
{
	CModel::Draw();
}

//******************************
// コース床の当たり判定
//******************************
void CCourse::CollisionPlayer(void)
{
	// プレイヤー数分ループ
	for (int nCntPlayer = 0; nCntPlayer < CGame::GetPlayerNum(); nCntPlayer++)
	{
		// プレイヤー座標の取得
		D3DXVECTOR3 playerPos = CGame::GetPlayer(nCntPlayer)->GetPos();

		BOOL bHit = FALSE;     // レイが当たっているか
		float fDistance = 0.0f;// レイが当たっている距離

		// レイ
		D3DXIntersect(m_pMeshModel[m_courseType],
			&playerPos,
			&D3DXVECTOR3(0.0f, -1.0f, 0.0f),
			&bHit,
			NULL,
			NULL,
			NULL,
			&fDistance,
			NULL,
			NULL);

		if (bHit)
		{// レイが当たっていたら

			if (fDistance <= HOVER_HEIGHT-1)
			{// 床とプレイヤーの距離を一定以上に保つ
				
				// プレイヤーの座標の更新
				playerPos.y = (playerPos.y - fDistance) + HOVER_HEIGHT;
				CGame::GetPlayer(nCntPlayer)->SetPos(playerPos);

				if (CGame::GetPlayer(nCntPlayer)->GetActiveGravity())
				{// 重力フラグが立っているとき
					// 重力を切る
					CGame::GetPlayer(nCntPlayer)->SetActiveGravity(false);
				}
			}
			else if (fDistance >= HOVER_HEIGHT - 1 && fDistance <= HOVER_HEIGHT + 20)
			{// ある程度の範囲だったらコースに吸い付ける
				
		        // プレイヤーの座標の更新
				playerPos.y = (playerPos.y - fDistance) + HOVER_HEIGHT;
				CGame::GetPlayer(nCntPlayer)->SetPos(playerPos);

				if (CGame::GetPlayer(nCntPlayer)->GetActiveGravity())
				{// 重力フラグが立っているとき
				    // 重力を切る
					CGame::GetPlayer(nCntPlayer)->SetActiveGravity(false);
				}
			}
			else
			{// 床から離れすぎてい時
				if (!CGame::GetPlayer(nCntPlayer)->GetActiveGravity())
				{// 重力フラグが立ってないとき
				 // 重力フラグを建てる
					CGame::GetPlayer(nCntPlayer)->SetActiveGravity(true);
				}
			}
		}
		else
		{// 自分の下に床がない
			if (!CGame::GetPlayer(nCntPlayer)->GetActiveGravity())
			{// 重力フラグが立ってないとき
			    // 重力フラグを建てる
				CGame::GetPlayer(nCntPlayer)->SetActiveGravity(true);
			}
		}
	}
}
